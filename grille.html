<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Grille PSE - V18 (Audit complet â€” 21 fixes)</title>

  <!-- FIX #22 : Chargement fichiers externes avec fallback si manquants -->
  <script src="data_eleves.js" onerror="console.warn('âš ï¸ data_eleves.js non trouvÃ© â€” annuaire indisponible'); window.DATA_ELEVES=window.DATA_ELEVES||{};"></script>
  <script src="data_commentaires_competences.js" onerror="console.warn('âš ï¸ data_commentaires_competences.js non trouvÃ© â€” banque commentaires vide'); window.DATA_COMMENTAIRES_COMPETENCES=window.DATA_COMMENTAIRES_COMPETENCES||{};"></script>
  <script src="data_appreciation.js" onerror="console.warn('âš ï¸ data_appreciation.js non trouvÃ© â€” banque apprÃ©ciations vide'); window.DATA_APPRECIATION=window.DATA_APPRECIATION||{};"></script>
  <script src="annuaire_local.js" onerror="console.warn('annuaire_local.js non disponible');"></script>

  <style>
    @page { size: A4; margin: 8mm; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 210mm;
      margin: 0 auto;
      padding: 10px 15px;
      background-color: #fff;
      color: #333;
      font-size: 0.9em;
    }

    .tools-container {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      max-width: 95vw;
    }

    .action-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      font-size: 1.05em;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.08);
      user-select: none;
      white-space: nowrap;
    }
    .action-btn:hover { background: #f0f0f0; }

    .action-btn.save-btn { background: #dcfce7; border-color: #16a34a; color: #166534; }
    .action-btn.save-btn:hover { background: #bbf7d0; }
    .action-btn.auth-btn { background: #dbeafe; border-color: #3b82f6; color: #1d4ed8; }
    .action-btn.toggle-btn { background: #fff7ed; border-color: #fb923c; color: #9a3412; }
    .action-btn.toggle-btn.active { background: #ffedd5; border-color: #f97316; color: #7c2d12; }

    #saveMessage {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: #16a34a;
      color: white;
      padding: 8px 15px;
      border-radius: 6px;
      font-size: 0.85em;
      opacity: 0;
      transition: opacity 0.5s;
      font-weight: bold;
      z-index: 3000;
    }

    .status-banner {
      background: #fef3c7;
      border: 1px solid #f59e0b;
      color: #92400e;
      padding: 8px 15px;
      border-radius: 8px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85em;
    }
    .status-banner.saved { background: #dcfce7; border-color: #16a34a; color: #166534; }
    .status-banner.not-saved { background: #fee2e2; border-color: #dc2626; color: #991b1b; }
    .status-banner.auth-required { background: #dbeafe; border-color: #3b82f6; color: #1d4ed8; }

    h1 {
      text-align: center;
      color: #d9534f;
      margin: 0 0 5px 0;
      border-bottom: 2px solid #d9534f;
      padding-bottom: 5px;
      font-size: 1.4em;
    }

    .header-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      background-color: #f8f9fa;
      padding: 5px 10px;
      border-radius: 6px;
      border: 1px solid #ddd;
    }
    .input-group { display: flex; flex-direction: column; flex-grow: 1; }
    .input-group label { font-size: 0.75em; color: #666; font-weight: bold; }
    .input-group input {
      padding: 3px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.95em;
      font-weight: bold;
      color: #0f172a;
    }

    .appreciation-box { margin-bottom: 10px; position: relative; }
    .appreciation-box label {
      font-weight: bold;
      color: #2e7bb6;
      cursor: pointer;
      text-decoration: underline;
      font-size: 0.85em;
      display:flex;
      align-items:center;
      gap:5px;
      margin-bottom: 3px;
    }
    .appreciation-box textarea {
      width: 100%;
      min-height: 50px;
      padding: 8px;
      border: 2px solid #2e7bb6;
      border-radius: 6px;
      background-color: #f0f8ff;
      resize: none;
      font-family: inherit;
      font-size: 0.9em;
      overflow-y: hidden;
      box-sizing: border-box;
    }

    table { width: 100%; border-collapse: collapse; margin-bottom: 5px; }
    th, td { border: 1px solid #ccc; padding: 3px 5px; text-align: center; vertical-align: middle; }

    .thead-dark { background-color: #333; color: white; }
    .thead-light { background-color: #f4f4f4; color: #333; font-weight: bold; font-size: 0.8em; }
    .correction-th { background-color: #d9534f; color: white; cursor: pointer; user-select: none; font-size: 0.85em; }

    .badge {
      display: inline-block;
      color: white;
      padding: 2px 0;
      width: 25px;
      text-align: center;
      border-radius: 4px;
      font-weight: bold;
      font-size: 0.8em;
    }
    .c1 { background-color: #7f8c8d; } .c2 { background-color: #66a5ad; } .c3 { background-color: #b03052; }
    .c4 { background-color: #2e7bb6; } .c5 { background-color: #5cb85c; } .c6 { background-color: #f0c05a; }

    .stat-counters {
      font-size: 0.75em;
      color: #666;
      margin-top: 3px;
      display: flex;
      justify-content: center;
      gap: 8px;
      background: #f9f9f9;
      padding: 2px;
      border-radius: 4px;
    }

    .score-input {
      width: 46px;
      text-align: center;
      font-weight: bold;
      border: 1px solid #ccc;
      padding: 2px;
      border-radius: 4px;
      font-size: 1em;
      background: #fff;
    }
    .max-input {
      width: 42px;
      text-align: center;
      border: none;
      font-weight:bold;
      color: #666;
      font-size: 0.9em;
      background: transparent;
    }

    input[type="radio"] { transform: scale(1.1); cursor: pointer; }

    tfoot { border-top: 2px solid #333; background-color: #fffef0; }
    .total-label { text-align: right; font-weight: bold; font-size: 1.1em; padding-right: 15px; }
    .total-points { font-weight: bold; text-align: center; width: 120px; vertical-align: middle; }
    .total-note { font-weight: 900; font-size: 1.4em; color: #d9534f; display: block; line-height: 1.2; }

    .level-btn {
      border: 1px solid #ddd;
      background: #f9f9f9;
      font-size: 0.7em;
      padding: 3px 6px;
      cursor: pointer;
      border-radius: 4px;
      font-weight: bold;
      color: #aaa;
      transition: 0.15s;
      user-select: none;
    }
    .level-btn:hover { background: #eee; color:#333; }
    .level-btn.active { border: 2px solid #333; color: #fff; transform: scale(1.06); }
    .level-btn.active.nt { background: #7f8c8d; border-color: #7f8c8d; }
    .level-btn.active.i  { background: #d9534f; border-color: #d9534f; }
    .level-btn.active.a  { background: #f0c05a; border-color: #f0c05a; }
    .level-btn.active.m  { background: #5cb85c; border-color: #5cb85c; }

    .editable-div {
      min-height: 25px;
      max-height: 150px; /* FIX #18 : limiter la hauteur */
      overflow-y: auto;  /* FIX #18 : scroll si trop long */
      text-align: left;
      outline: none;
      padding: 6px;
      font-size: 0.9em;
      border: 1px dashed #ccc;
      cursor: text;
      background: #fff;
      border-radius: 6px;
      line-height: 1.25;
      white-space: pre-wrap;
    }
    .editable-div:focus { background-color: #e8f0fe; border-color: #2e7bb6; border-style: solid; }
    .editable-div:empty::before { content: attr(placeholder); color: #ccc; font-style: italic; }

    .bottom-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
      gap: 10px;
      flex-wrap: wrap;
    }
    .legend-box { font-size: 0.75em; color: #555; font-style: italic; }

    .revision-box {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #f8fafc;
      border: 1px dashed #94a3b8;
      border-radius: 8px;
      padding: 5px 10px;
    }
    .revision-text { font-size: 0.75em; color: #475569; text-align: right; line-height: 1.2; }
    .qr-img { height: 40px; width: 40px; mix-blend-mode: multiply; }

    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    .modal-box {
      background: white;
      width: 650px;
      max-width: 95%;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      max-height: 85vh;
    }
    .modal-header {
      padding: 10px 15px;
      border-bottom: 1px solid #eee;
      background: #f8f9fa;
      border-radius: 12px 12px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      color: #2e7bb6;
    }
    .modal-body { padding: 0; overflow-y: auto; }
    .bank-title {
      background: #f1f5f9;
      padding: 5px 15px;
      font-size: 0.8em;
      font-weight: bold;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-top: 1px solid #eee;
    }
    .comment-item {
      padding: 8px 15px;
      border-bottom: 1px solid #f9f9f9;
      cursor: pointer;
      font-size: 0.9em;
      transition: background 0.1s;
      line-height: 1.25;
      white-space: pre-wrap;
    }
    .comment-item:hover { background-color: #e0f2fe; color: #0284c7; }

    .qa-stack { text-align: left; }
    .qa-block {
      border-radius: 10px;
      padding: 10px 12px;
      margin-bottom: 8px;
      line-height: 1.25;
      white-space: normal;
    }
    .qa-title {
      font-weight: 800;
      margin: 0 0 6px 0;
      font-size: 0.95em;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75em;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid transparent;
      user-select: none;
      white-space: nowrap;
    }
    .pill.q { background: #fff7ed; border-color: #fdba74; color: #9a3412; }
    .pill.e { background: #ecfeff; border-color: #67e8f9; color: #155e75; }
    .pill.a { background: #f0fdf4; border-color: #86efac; color: #166534; }

    .qa-question { background: #fff7ed; border: 1px solid #fdba74; }
    .qa-student  { background: #f0f9ff; border: 1px solid #93c5fd; }
    .qa-expected { background: #f0fdf4; border: 1px dashed #86efac; }

    .qa-content { white-space: pre-wrap; }
    .qa-content ul { margin: 6px 0 0 18px; padding: 0; }
    .qa-content li { margin: 2px 0; }

    .hidden { display: none !important; }

    @media print {
      .no-print { display: none !important; }
      body { padding: 0; margin: 0; background: white; }
      .status-banner { display: none !important; }
      .rep-prof-box { display: none; }
      .header-row, .revision-box { border: 1px solid #eee; }
      .input-group input { border: none; border-bottom: 1px solid #333; border-radius: 0; padding: 0; }
      textarea { border: 1px solid #333 !important; background: transparent !important; }
      .editable-div { border: none; }
      .score-input, .max-input { border: none; text-align: right; width: auto; font-weight: bold; }
      tr[style*="display: none"] { display: none !important; }
      .qa-block { break-inside: avoid; page-break-inside: avoid; }
    }
  </style>
</head>

<body>

  <div class="tools-container no-print">
    <button id="authBtn" class="action-btn auth-btn" onclick="connexionProf()">ðŸ” Connexion</button>

    <button id="toggleQuestionBtn" class="action-btn toggle-btn active" onclick="toggleShowQuestion()">ðŸ‘ï¸ Question</button>
    <button id="toggleExpectedBtn" class="action-btn toggle-btn active" onclick="toggleShowExpected()">ðŸŽ¯ Attendu</button>

    <button class="action-btn" onclick="scrollToNextUnrated()">âž¡ï¸ Non notÃ©es</button>

    <!-- FIX #16 : Bouton aperÃ§u copie intÃ©grÃ© -->
    <button class="action-btn" onclick="ouvrirApercuCopie()" style="background:#f0f9ff; color:#0369a1; border:1px solid #93c5fd;">ðŸ‘ï¸ Copie</button>

    <button class="action-btn draft-btn" onclick="sauvegarderBrouillon()" style="background:#e0f2fe; color:#0369a1; border:1px solid #0ea5e9;">ðŸ’¾ Brouillon</button>

    <div style="display:flex; align-items:center; gap:5px; background:#f0fdf4; padding:5px 10px; border-radius:8px; border:1px solid #16a34a;">
      <select id="publishType" style="padding:5px; border-radius:6px; border:1px solid #ccc; font-size:0.95em;">
        <option value="note">ðŸ“Š NotÃ©</option>
        <option value="nn">âš ï¸ Non notÃ©</option>
        <option value="absent">ðŸš« Absent</option>
      </select>
      <button class="action-btn save-btn" onclick="publierCorrection()">âœ… Publier</button>
    </div>

    <button class="action-btn" onclick="window.print()">ðŸ–¨ï¸ Imprimer</button>
    <button class="action-btn" onclick="resetNewStudent()">â™»ï¸ Autre copie</button>
    <span id="annuaireContainer"></span>
  </div>

  <div id="saveMessage">âœ… Correction enregistrÃ©e !</div>

  <div id="confirmModal" class="modal-overlay no-print">
    <div class="modal-box" style="width:400px; text-align:center;">
      <div class="modal-header">
        <span>âœ… Confirmation</span>
        <span style="cursor:pointer; font-size:1.5em;" onclick="fermerConfirmModal()">Ã—</span>
      </div>
      <div style="padding:20px;">
        <div id="confirmIcon" style="font-size:3em; margin-bottom:10px;">âœ…</div>
        <div id="confirmMessage" style="font-size:1.1em; color:#166534; margin-bottom:15px;">Correction publiÃ©e !</div>
        <div id="confirmDetails" style="font-size:0.9em; color:#64748b;"></div>
        <button onclick="fermerConfirmModal()" style="margin-top:15px; padding:8px 20px; background:#16a34a; color:white; border:none; border-radius:8px; cursor:pointer; font-size:1em;">OK</button>
      </div>
    </div>
  </div>

  <div id="statusBanner" class="status-banner no-print">
    <span id="statusText">â³ Chargement...</span>
    <span id="statusDate"></span>
  </div>

  <div id="commentModal" class="modal-overlay no-print">
    <div class="modal-box">
      <div class="modal-header">
        <span id="modalTitle">Banque</span>
        <span style="cursor:pointer; font-size:1.5em;" onclick="closeModal()">Ã—</span>
      </div>
      <div id="modalList" class="modal-body"></div>
    </div>
  </div>

  <!-- FIX #16 : Modal aperÃ§u copie intÃ©grÃ© -->
  <div id="copyPreviewModal" class="modal-overlay no-print">
    <div class="modal-box" style="width:750px;">
      <div class="modal-header" style="background:#f0f9ff;">
        <span>ðŸ‘ï¸ AperÃ§u copie Ã©lÃ¨ve</span>
        <span style="cursor:pointer; font-size:1.5em;" onclick="document.getElementById('copyPreviewModal').style.display='none'">Ã—</span>
      </div>
      <div id="copyPreviewBody" class="modal-body" style="padding:15px; max-height:75vh; overflow-y:auto;"></div>
    </div>
  </div>

  <h1 id="docTitle">Correction</h1>

  <div class="header-row">
    <div class="input-group grow"><label>Nom :</label><input type="text" id="inputNom"></div>
    <div class="input-group grow"><label>PrÃ©nom :</label><input type="text" id="inputPrenom"></div>
    <div class="input-group" style="width:80px;"><label>Classe :</label><input type="text" id="inputClasse"></div>
    <div class="input-group" style="width:110px;"><label>Date :</label><input type="date" id="inputDate"></div>
  </div>

  <div class="appreciation-box">
    <label onclick="openAppreciationBank()">ðŸ“ ApprÃ©ciation GÃ©nÃ©rale (cliquez pour ouvrir la banque)</label>
    <textarea id="appreciationArea" oninput="autoResize(this); markUnsaved(); updateCharCount();"></textarea>
    <!-- FIX #15 : Compteur de caractÃ¨res -->
    <div id="charCount" style="text-align:right; font-size:0.75em; color:#94a3b8; margin-top:2px;">0 caractÃ¨res</div>
  </div>

  <table id="summaryTable">
    <thead>
      <tr class="thead-dark">
        <th rowspan="2" style="width:30px;">C</th>
        <th rowspan="2">CompÃ©tences Ã©valuÃ©es</th>
        <th colspan="4" class="thead-light">Niveau</th>
        <th rowspan="2" style="width:120px; background:#fff; color:#333;">Pts / Max</th>
      </tr>
      <tr class="thead-light">
        <th style="width:25px;">NT</th><th style="width:25px;">I</th><th style="width:25px;">A</th><th style="width:25px;">M</th>
      </tr>
    </thead>
    <tbody id="gradingBody"></tbody>
    <tfoot>
      <tr>
        <td colspan="6" class="total-label">NOTE :</td>
        <td class="total-points"><span id="finalNote" class="total-note">-- / 20</span></td>
      </tr>
    </tfoot>
  </table>

  <div class="bottom-container">
    <div class="legend-box">* NT : Non TraitÃ© &nbsp; I : Insuffisant &nbsp; A : Acceptable &nbsp; M : MaÃ®trisÃ© &nbsp; | &nbsp; âŒ¨ï¸ <b>Raccourcis :</b> 1=NT 2=I 3=A 4=M, Tab=suivante</div>
    <div class="revision-box">
      <div class="revision-text">Pour rÃ©viser :<br><b>preventionsanteenvironnement.github.io/PSE/</b></div>
      <img src="https://api.qrserver.com/v1/create-qr-code/?size=100x100&data=https://preventionsanteenvironnement.github.io/PSE/" alt="QR" class="qr-img">
    </div>
  </div>

  <h3 style="margin-top:10px; color:#555; border-bottom:1px solid #eee; padding-bottom:5px;">DÃ©tail de l'Ã©valuation</h3>

  <!-- FIX #12 : Barre de progression -->
  <div id="progressBar" class="no-print" style="background:#f1f5f9; border-radius:8px; padding:6px 12px; margin-bottom:8px; display:flex; align-items:center; gap:10px; font-size:0.85em;">
    <span id="progressText" style="font-weight:bold; color:#475569;">0 / 0 questions notÃ©es</span>
    <div style="flex:1; background:#e2e8f0; border-radius:4px; height:8px; overflow:hidden;">
      <div id="progressFill" style="width:0%; height:100%; background:#16a34a; border-radius:4px; transition:width 0.3s;"></div>
    </div>
    <span id="progressPct" style="font-weight:bold; color:#16a34a;">0%</span>
  </div>

  <table id="correctionTable">
    <thead>
      <tr>
        <th class="correction-th" onclick="sortTable(0)" style="width:60px;">QÂ° â‡…</th>
        <th class="correction-th" onclick="sortTable(1)" style="width:40px;">C â‡…</th>
        <th class="correction-th" onclick="sortTable(2)" style="width:110px;">Niveau â‡…</th>
        <th class="correction-th">Question / RÃ©ponse Ã©lÃ¨ve / Attendu</th>
        <th class="correction-th" style="width:30%;">Commentaires</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";
    import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-auth.js";

    // FIX #19 : La config Firebase cÃ´tÃ© client est normale (clÃ© API publique).
    // âš ï¸ La SÃ‰CURITÃ‰ repose sur les Firestore Security Rules cÃ´tÃ© serveur.
    // VÃ©rifier que les rÃ¨gles limitent l'Ã©criture dans "resultats/{eleveCode}" aux profs authentifiÃ©s.
    // Exemple de rÃ¨gle recommandÃ©e :
    //   match /resultats/{code}/evaluations/{evalId} {
    //     allow read: if true;
    //     allow write: if request.auth != null && request.auth.token.email_verified;
    //   }
    const firebaseConfig = {
      apiKey: "AIzaSyAWdCMvOiAJln3eT9LIAQD3RWJUD0lQcLI",
      authDomain: "devoirs-pse.firebaseapp.com",
      projectId: "devoirs-pse",
      storageBucket: "devoirs-pse.appspot.com",
      messagingSenderId: "614730413904",
      appId: "1:614730413904:web:a5dd478af5de30f6bede55"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const googleProvider = new GoogleAuthProvider();

    let currentUser = null;
    let CURRENT_TARGET_DIV = null;
    let CURRENT_BLUEPRINT = null;
    let CURRENT_DOC_ID = null;
    let CURRENT_ELEVE_CODE = null;
    let CURRENT_COPY = null;
    let CURRENT_EVALUATION = null;
    let IS_SAVED = true;

    const comps = ['C1','C2','C3','C4','C5','C6'];

    // FIX #20 : Helper pour les erreurs Firebase avec dÃ©tection quota/permission
    function handleFirebaseError(e, context) {
      const code = e?.code || '';
      const msg = e?.message || String(e);
      if (code === 'resource-exhausted' || msg.includes('quota')) {
        alert(`âš ï¸ Quota Firebase dÃ©passÃ© (${context}).\n\nLes lectures/Ã©critures sont temporairement limitÃ©es.\nRÃ©essayez dans quelques minutes.`);
        console.error(`ðŸ”¥ QUOTA Firebase (${context}):`, e);
      } else if (code === 'permission-denied' || msg.includes('permission')) {
        alert(`ðŸ”’ Permission refusÃ©e (${context}).\n\nVÃ©rifiez que vous Ãªtes bien connectÃ© et que les rÃ¨gles Firestore sont correctes.`);
        console.error(`ðŸ”’ PERMISSION Firebase (${context}):`, e);
      } else if (code === 'unavailable' || msg.includes('offline') || msg.includes('network')) {
        alert(`ðŸ“¡ Connexion perdue (${context}).\n\nVÃ©rifiez votre connexion internet et rÃ©essayez.`);
        console.error(`ðŸ“¡ RÃ‰SEAU Firebase (${context}):`, e);
      } else {
        alert(`âŒ Erreur (${context}) :\n\n${msg}`);
        console.error(`âŒ Firebase (${context}):`, e);
      }
    }

    let SHOW_QUESTION = true;
    let SHOW_EXPECTED = true;

    window.autoResize = autoResize;
    window.openAppreciationBank = openAppreciationBank;
    window.closeModal = closeModal;
    window.sortTable = sortTable;
    window.markUnsaved = markUnsaved;
    window.ouvrirApercuCopie = ouvrirApercuCopie;
    window.setGlobalLevel = setGlobalLevel;
    window.resetNewStudent = resetNewStudent;
    window.setNoteVisual = setNoteVisual;
    window.calculateTotal = calculateTotal;
    window.connexionProf = connexionProf;

    window.toggleShowQuestion = toggleShowQuestion;
    window.toggleShowExpected = toggleShowExpected;
    window.scrollToNextUnrated = scrollToNextUnrated;

    onAuthStateChanged(auth, (user) => {
      currentUser = user;
      updateAuthButton();
      updateStatusBanner();
      if (user) console.log("âœ… Prof connectÃ©:", user.email);
    });

    function updateAuthButton() {
      const btn = document.getElementById('authBtn');
      if (currentUser) {
        btn.textContent = "âœ… " + currentUser.email.split('@')[0];
        btn.style.background = "#dcfce7";
        btn.style.color = "#166534";
        btn.style.borderColor = "#16a34a";
      } else {
        btn.textContent = "ðŸ” Connexion";
        btn.style.background = "#dbeafe";
        btn.style.color = "#1d4ed8";
        btn.style.borderColor = "#3b82f6";
      }
    }

    async function connexionProf() {
      try {
        const result = await signInWithPopup(auth, googleProvider);
        currentUser = result.user;
        console.log("âœ… ConnectÃ©:", currentUser.email, "UID:", currentUser.uid);
        alert("âœ… ConnectÃ©: " + currentUser.email + "\n\nUID (pour les rÃ¨gles):\n" + currentUser.uid);
        updateAuthButton();
        updateStatusBanner();
      } catch (error) {
        console.error("âŒ Erreur:", error);
        alert("Erreur: " + error.message);
      }
    }

    // FIX #21 : autoResize avec debounce (Ã©vite recalcul Ã  chaque frappe)
    let _resizeTimer = null;
    function autoResize(el) {
      if (_resizeTimer) clearTimeout(_resizeTimer);
      _resizeTimer = setTimeout(() => {
        el.style.height = 'auto';
        el.style.height = (el.scrollHeight) + 'px';
        _resizeTimer = null;
      }, 50);
    }
    // FIX #15 : Compteur de caractÃ¨res
    function updateCharCount() {
      const area = document.getElementById('appreciationArea');
      const counter = document.getElementById('charCount');
      if (area && counter) {
        const len = area.value.length;
        counter.textContent = len + ' caractÃ¨re' + (len > 1 ? 's' : '');
        counter.style.color = len > 500 ? '#d9534f' : '#94a3b8';
      }
    }
    function markUnsaved() { IS_SAVED = false; updateStatusBanner(); }

    function updateStatusBanner() {
      const banner = document.getElementById('statusBanner');
      const text = document.getElementById('statusText');
      const dateEl = document.getElementById('statusDate');
      banner.classList.remove('saved', 'not-saved', 'auth-required');

      if (!currentUser) {
        banner.classList.add('auth-required');
        text.innerHTML = 'ðŸ” Connectez-vous pour enregistrer';
        dateEl.textContent = '';
      } else if (IS_SAVED && CURRENT_EVALUATION?.savedAt) {
        banner.classList.add('saved');
        text.innerHTML = 'âœ… Correction enregistrÃ©e';
        const d = new Date(CURRENT_EVALUATION.savedAt);
        dateEl.textContent = 'le ' + d.toLocaleDateString('fr-FR') + ' Ã  ' + d.toLocaleTimeString('fr-FR', {hour:'2-digit', minute:'2-digit'});
      } else if (!IS_SAVED) {
        banner.classList.add('not-saved');
        text.innerHTML = 'âš ï¸ Modifications non enregistrÃ©es';
        dateEl.textContent = '';
      } else {
        text.innerHTML = 'ðŸ“ Nouvelle correction';
        dateEl.textContent = '';
      }
    }

    function showSaveMessage(success = true) {
      const msg = document.getElementById('saveMessage');
      msg.textContent = success ? 'âœ… Correction enregistrÃ©e !' : 'âŒ Erreur de sauvegarde';
      msg.style.background = success ? '#16a34a' : '#dc2626';
      msg.style.opacity = 1;
      setTimeout(() => msg.style.opacity = 0, 2000);
    }

    function loadPreferences() {
      try {
        const s = JSON.parse(localStorage.getItem("grille_pref_v17") || "{}");
        SHOW_QUESTION = (s.SHOW_QUESTION !== undefined) ? !!s.SHOW_QUESTION : true;
        SHOW_EXPECTED = (s.SHOW_EXPECTED !== undefined) ? !!s.SHOW_EXPECTED : true;
      } catch(e) {}
      syncToggleButtons();
    }

    function savePreferences() {
      localStorage.setItem("grille_pref_v17", JSON.stringify({
        SHOW_QUESTION,
        SHOW_EXPECTED
      }));
    }

    function syncToggleButtons() {
      const qBtn = document.getElementById('toggleQuestionBtn');
      const eBtn = document.getElementById('toggleExpectedBtn');
      if (qBtn) qBtn.classList.toggle('active', SHOW_QUESTION);
      if (eBtn) eBtn.classList.toggle('active', SHOW_EXPECTED);

      document.querySelectorAll('.qa-question').forEach(el => el.classList.toggle('hidden', !SHOW_QUESTION));
      document.querySelectorAll('.qa-expected').forEach(el => el.classList.toggle('hidden', !SHOW_EXPECTED));
    }

    function toggleShowQuestion() {
      SHOW_QUESTION = !SHOW_QUESTION;
      savePreferences();
      syncToggleButtons();
    }

    function toggleShowExpected() {
      SHOW_EXPECTED = !SHOW_EXPECTED;
      savePreferences();
      syncToggleButtons();
    }

    // FIX #16 : AperÃ§u copie intÃ©grÃ©
    function ouvrirApercuCopie() {
      if (!CURRENT_COPY || !CURRENT_COPY.reponses) {
        alert("Aucune copie chargÃ©e.");
        return;
      }
      const reponses = CURRENT_COPY.reponses;
      const meta = CURRENT_COPY.eleve || CURRENT_COPY;
      let html = `<div style="margin-bottom:10px; padding:8px; background:#f8fafc; border-radius:8px; font-size:0.85em; color:#475569;">
        <b>Code :</b> ${escapeHTML(CURRENT_ELEVE_CODE)} &nbsp;|&nbsp;
        <b>Classe :</b> ${escapeHTML(meta.classe || '')} &nbsp;|&nbsp;
        <b>Date :</b> ${escapeHTML(CURRENT_COPY.submittedAt ? new Date(CURRENT_COPY.submittedAt).toLocaleString('fr-FR') : 'N/A')}
      </div>`;

      // Stats copier-coller si disponibles
      if (CURRENT_COPY.pasteStats) {
        const ps = CURRENT_COPY.pasteStats;
        const total = ps.totalPastes || 0;
        if (total > 0) {
          html += `<div style="background:#fef3c7; border:1px solid #f59e0b; padding:6px 10px; border-radius:6px; margin-bottom:10px; font-size:0.85em; color:#92400e;">
            âš ï¸ <b>${total}</b> copier-coller dÃ©tectÃ©${total > 1 ? 's' : ''}
          </div>`;
        }
      }

      // Lister toutes les rÃ©ponses
      const questions = extractQuestionsFromBlueprint(CURRENT_BLUEPRINT || {});
      if (questions.length > 0) {
        questions.forEach((q, idx) => {
          const label = q?.label || ("Q" + (idx + 1));
          const qText = q?.questionText || q?.question || q?.enonce || q?.texte || "";
          const rep = getReponseEleve(reponses, q);
          html += `<div style="border:1px solid #e2e8f0; border-radius:8px; padding:8px 10px; margin-bottom:6px;">
            <div style="font-weight:bold; font-size:0.85em; color:#334155; margin-bottom:4px;">
              ${escapeHTML(label)} ${qText ? 'â€” ' + escapeHTML(qText).substring(0, 80) + (qText.length > 80 ? '...' : '') : ''}
            </div>
            <div style="font-size:0.9em; color:#1e293b; padding-left:8px; border-left:3px solid #93c5fd;">${rep}</div>
          </div>`;
        });
      } else {
        // Fallback : afficher les clÃ©s brutes
        for (const [key, val] of Object.entries(reponses)) {
          html += `<div style="border:1px solid #e2e8f0; border-radius:8px; padding:8px 10px; margin-bottom:6px;">
            <div style="font-weight:bold; font-size:0.85em; color:#334155;">${escapeHTML(key)}</div>
            <div style="font-size:0.9em; padding-left:8px; border-left:3px solid #93c5fd;">${formatMaybeBullets(val)}</div>
          </div>`;
        }
      }

      document.getElementById('copyPreviewBody').innerHTML = html;
      document.getElementById('copyPreviewModal').style.display = 'flex';
    }

    function scrollToNextUnrated() {
      const rows = Array.from(document.querySelectorAll('#correctionTable tbody tr'));
      const target = rows.find(r => !r.dataset.level);
      if (target) target.scrollIntoView({ behavior: "smooth", block: "center" });
      else alert("âœ… Toutes les questions ont un niveau.");
    }

    function extractQuestionsFromBlueprint(blueprint) {
      if (Array.isArray(blueprint?.questions)) return blueprint.questions;
      const questions = [];
      function walk(blocks) {
        if (!Array.isArray(blocks)) return;
        blocks.forEach(b => {
          if (b && b.type === "question") questions.push(b);
          if (b && b.content) walk(b.content);
        });
      }
      walk(blueprint?.content);
      return questions;
    }

    function escapeHTML(str) {
      return String(str ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function splitToBullets(text) {
      const raw = String(text ?? "").trim();
      if (!raw) return [];
      let t = raw.replace(/\r/g, "");
      t = t.replace(/â€¢/g, "\nâ€¢ ");
      t = t.replace(/\s*-\s+/g, "\n- ");
      t = t.replace(/\s*;\s*/g, "\n");
      const lines = t.split("\n").map(l => l.trim()).filter(l => l && l !== "-" && l !== "â€¢");
      return lines;
    }

    function formatMaybeBullets(value) {
      if (value === null || value === undefined) return "<i>Non rÃ©pondu</i>";

      if (Array.isArray(value)) {
        const items = value.map(v => String(v).trim()).filter(Boolean);
        if (!items.length) return "<i>Non rÃ©pondu</i>";
        if (items.length === 1) return escapeHTML(items[0]);
        return "<ul>" + items.map(i => "<li>" + escapeHTML(i) + "</li>").join("") + "</ul>";
      }

      if (typeof value === "object") {
        const entries = Object.entries(value);
        if (!entries.length) return "<i>Non rÃ©pondu</i>";
        return "<ul>" + entries.map(([k,v]) => "<li><b>" + escapeHTML(k) + "</b> : " + escapeHTML(v) + "</li>").join("") + "</ul>";
      }

      const s = String(value ?? "").trim();
      if (!s) return "<i>Non rÃ©pondu</i>";

      const bullets = splitToBullets(s);
      if (bullets.length >= 2) {
        return "<ul>" + bullets.map(i => "<li>" + escapeHTML(i) + "</li>").join("") + "</ul>";
      }
      return escapeHTML(s);
    }

    function renderQuestionHTML(q, label, competence) {
      const qt = q?.questionText || q?.question || q?.enonce || q?.texte || "";
      const txt = String(qt ?? "").trim();
      const safe = txt ? escapeHTML(txt) : "<i>Question non fournie</i>";
      const compPill = competence ? `<span class="pill e">${escapeHTML(competence)}</span>` : "";
      const labPill = label ? `<span class="pill q">${escapeHTML(label)}</span>` : "";
      return `
        <div class="qa-block qa-question">
          <div class="qa-title">${labPill}${compPill}<span class="pill q">Question</span></div>
          <div class="qa-content">${safe.replaceAll("\n","<br>")}</div>
        </div>
      `;
    }

    function getReponseEleve(reponses, q) {
      if (!reponses) return "<i>Non rÃ©pondu</i>";
      const qid = q?.qid;
      const label = q?.label;

      // FIX #9 : Mapping intelligent â€” essayer toutes les variantes de clÃ©s
      const keysToTry = [];
      if (qid) keysToTry.push(qid);                                    // q_0
      if (label) keysToTry.push(label);                                 // 1.1
      if (label) keysToTry.push("Q" + label);                           // Q1.1
      if (qid) keysToTry.push(qid.replace("q_", "Q"));                 // Q0
      if (label) keysToTry.push("Q" + label.replace(".", "_"));         // Q1_1
      if (qid) {
        // Variantes avec suffixes courants (matrice, gravitÃ©, dÃ©cision, trous)
        ["_gravite", "_decision", "_matrice", "_trous", "_source"].forEach(suffix => {
          keysToTry.push(qid + suffix);
        });
      }

      for (const key of keysToTry) {
        if (key && reponses[key] !== undefined) return formatMaybeBullets(reponses[key]);
      }

      // FIX #9 : Recherche partielle â€” si qid contient le dÃ©but d'une clÃ© dans reponses
      if (qid) {
        for (const rKey of Object.keys(reponses)) {
          if (rKey.startsWith(qid + "_") || rKey.startsWith(qid + ".")) {
            // Grouper toutes les sous-rÃ©ponses
            const subKeys = Object.keys(reponses).filter(k => k.startsWith(qid + "_") || k.startsWith(qid + "."));
            if (subKeys.length > 0) {
              const grouped = {};
              subKeys.forEach(sk => {
                const suffix = sk.replace(qid, "").replace(/^[_.]/, "");
                grouped[suffix || sk] = reponses[sk];
              });
              return formatMaybeBullets(grouped);
            }
          }
        }
      }

      return "<i>Non rÃ©pondu</i>";
    }

    function formatExpected(q) {
      const att = q?.reponseAttendue ?? q?.attendu ?? q?.corrige ?? "";
      const s = String(att ?? "").trim();
      if (!s) return "<i>Non renseignÃ©</i>";
      const bullets = splitToBullets(s);
      if (bullets.length >= 2) {
        return "<ul>" + bullets.map(i => "<li>" + escapeHTML(i) + "</li>").join("") + "</ul>";
      }
      return escapeHTML(s).replaceAll("\n","<br>");
    }

    function collecterDonneesCorrection() {
      const data = {
        savedAt: new Date().toISOString(),
        savedBy: currentUser?.email || "anonyme",
        profUid: currentUser?.uid || "",
        eleveCode: CURRENT_ELEVE_CODE,
        classe: document.getElementById('inputClasse').value || "",
        devoirId: CURRENT_COPY?.devoirId || "unknown",
        titre: CURRENT_BLUEPRINT?.titre || CURRENT_COPY?.titre || "Devoir",
        copyDocId: CURRENT_DOC_ID,
        appreciation: document.getElementById('appreciationArea').value || "",
        competences: {},
        questions: {}
      };

      comps.forEach(c => {
        const ptsEl = document.getElementById(`pts_${c}`);
        const maxEl = document.getElementById(`max_${c}`);
        if (ptsEl && maxEl) {
          data.competences[c] = {
            pts: parseFloat(ptsEl.value) || 0,
            max: parseFloat(maxEl.value) || 0
          };
        }
      });

      document.querySelectorAll('#correctionTable tbody tr').forEach((row, idx) => {
        const qid = row.dataset.qid || `q_${idx}`;
        const commentDiv = row.querySelector('.editable-div');
        data.questions[qid] = {
          level: row.dataset.level || "",
          comment: commentDiv ? commentDiv.innerText.trim() : ""
        };
      });

      return data;
    }

    window.sauvegarderBrouillon = async function() {
      if (!currentUser) { alert("ðŸ” Connectez-vous d'abord !"); connexionProf(); return; }
      if (!CURRENT_ELEVE_CODE || CURRENT_ELEVE_CODE === "UNKNOWN") { alert("Erreur : Code Ã©lÃ¨ve manquant."); return; }

      try {
        const brouillon = collecterDonneesCorrection();
        brouillon.statut = "brouillon";
        brouillon.note_finale = parseFloat((document.getElementById('finalNote').textContent || "0").replace(",", ".")) || 0;
        brouillon.publie = false;

        const brouillonDocId = brouillon.devoirId + "_brouillon";
        await setDoc(doc(db, "resultats", CURRENT_ELEVE_CODE, "brouillons", brouillonDocId), brouillon);

        CURRENT_EVALUATION = brouillon;
        IS_SAVED = true;
        updateStatusBanner();

        afficherConfirmation("ðŸ’¾", "Brouillon sauvegardÃ© !", "Ton travail est enregistrÃ©.\nL'Ã©lÃ¨ve ne voit pas encore la correction.", "#0369a1");
      } catch (e) {
        console.error("âŒ Erreur:", e);
        showSaveMessage(false);
        handleFirebaseError(e, "sauvegarde brouillon"); // FIX #20
      }
    }

    let IS_PUBLISHING = false; // FIX #1+#5 : verrou anti-double-clic

    window.publierCorrection = async function() {
      if (IS_PUBLISHING) return; // FIX #1 : ignorer si dÃ©jÃ  en cours
      if (!currentUser) { alert("ðŸ” Connectez-vous d'abord !"); connexionProf(); return; }
      if (!CURRENT_ELEVE_CODE || CURRENT_ELEVE_CODE === "UNKNOWN") { alert("Erreur : Code Ã©lÃ¨ve manquant."); return; }

      const typePublication = document.getElementById('publishType').value;
      let noteFinale, statut, messageConfirm, iconConfirm, couleur;

      switch(typePublication) {
        case "note":
          noteFinale = parseFloat((document.getElementById('finalNote').textContent || "0").replace(",", ".")) || 0;
          statut = "notÃ©";
          messageConfirm = `Correction publiÃ©e avec la note ${noteFinale}/20`;
          iconConfirm = "âœ…";
          couleur = "#16a34a";
          break;
        case "nn":
          noteFinale = "NN";
          statut = "non_notÃ©";
          messageConfirm = "Copie publiÃ©e comme 'Non notÃ©'";
          iconConfirm = "âš ï¸";
          couleur = "#b45309";
          break;
        case "absent":
          noteFinale = "ABS";
          statut = "absent";
          messageConfirm = "Copie marquÃ©e comme 'Absent'";
          iconConfirm = "ðŸš«";
          couleur = "#dc2626";
          break;
      }

      if (!confirm(`Publier cette correction ?\n\n${messageConfirm}\n\nL'Ã©lÃ¨ve ${CURRENT_ELEVE_CODE} pourra voir sa correction.`)) return;

      // FIX #11 : Avertissement si la copie est dÃ©jÃ  publiÃ©e
      if (CURRENT_EVALUATION && CURRENT_EVALUATION.publie) {
        if (!confirm("âš ï¸ Cette copie a DÃ‰JÃ€ Ã©tÃ© publiÃ©e.\n\nVoulez-vous Ã©craser la correction existante ?")) return;
      }

      // FIX #5 : dÃ©sactiver le bouton visuellement pendant l'Ã©criture
      IS_PUBLISHING = true;
      const publishBtn = document.querySelector('.save-btn');
      const originalBtnText = publishBtn.textContent;
      publishBtn.textContent = "â³ Envoi...";
      publishBtn.disabled = true;
      publishBtn.style.opacity = "0.5";

      try {
        const evaluation = collecterDonneesCorrection();
        evaluation.note_finale = noteFinale;
        evaluation.statut = statut;
        evaluation.publie = true;

        if (typePublication === "nn") {
          evaluation.nonNote = true;
        } else if (typePublication === "absent") {
          evaluation.absent = true;
          evaluation.appreciation = evaluation.appreciation || "Absent(e) lors de l'Ã©valuation.";
        }

        const evalDocId = evaluation.devoirId + "_eval";
        await setDoc(doc(db, "resultats", CURRENT_ELEVE_CODE, "evaluations", evalDocId), evaluation);

        if (typePublication === "note") {
          document.getElementById('finalNote').style.color = "#d9534f";
        } else if (typePublication === "nn") {
          document.getElementById('finalNote').innerText = "Non notÃ©";
          document.getElementById('finalNote').style.color = "#b45309";
        } else if (typePublication === "absent") {
          document.getElementById('finalNote').innerText = "Absent";
          document.getElementById('finalNote').style.color = "#dc2626";
        }

        CURRENT_EVALUATION = evaluation;
        IS_SAVED = true;
        updateStatusBanner();

        // FIX #5 : bouton passe en "DÃ©jÃ  publiÃ©" aprÃ¨s succÃ¨s
        publishBtn.textContent = "âœ… PubliÃ©";
        publishBtn.style.opacity = "1";
        publishBtn.style.background = "#bbf7d0";

        afficherConfirmation(iconConfirm, messageConfirm, `L'Ã©lÃ¨ve ${CURRENT_ELEVE_CODE} peut maintenant voir sa correction.`, couleur);
      } catch (e) {
        console.error("âŒ Erreur:", e);
        showSaveMessage(false);
        handleFirebaseError(e, "publication correction"); // FIX #20
        publishBtn.textContent = originalBtnText;
        publishBtn.disabled = false;
        publishBtn.style.opacity = "1";
      } finally {
        IS_PUBLISHING = false;
        // FIX #5 : rÃ©activer aprÃ¨s 3s pour permettre une republication si besoin
        setTimeout(() => { publishBtn.disabled = false; }, 3000);
      }
    }

    function afficherConfirmation(icon, message, details, couleur) {
      document.getElementById('confirmIcon').textContent = icon;
      document.getElementById('confirmMessage').textContent = message;
      document.getElementById('confirmMessage').style.color = couleur;
      document.getElementById('confirmDetails').textContent = details;
      document.getElementById('confirmModal').style.display = 'flex';
    }

    window.fermerConfirmModal = function() {
      document.getElementById('confirmModal').style.display = 'none';
    }

    function loadExistingCorrection(correction) {
      if (!correction) return;

      if (correction.nonNote || correction.note_finale === "NN") {
        document.getElementById('finalNote').innerText = "Non notÃ©";
        document.getElementById('finalNote').style.color = "#b45309";
      }

      if (correction.appreciation) {
        const area = document.getElementById('appreciationArea');
        area.value = correction.appreciation;
        autoResize(area);
      }

      if (correction.competences) {
        for (const c in correction.competences) {
          const ptsEl = document.getElementById(`pts_${c}`);
          if (ptsEl && correction.competences[c]?.pts !== undefined) ptsEl.value = correction.competences[c].pts;
        }
      }

      if (correction.questions) {
        document.querySelectorAll('#correctionTable tbody tr').forEach((row, idx) => {
          const qid = row.dataset.qid || `q_${idx}`;
          const qData = correction.questions[qid];
          if (qData) {
            if (qData.level) {
              row.dataset.level = qData.level;
              const btn = row.querySelector(`.level-btn.${qData.level.toLowerCase()}`);
              if (btn) btn.classList.add('active');
            }
            if (qData.comment) {
              const commentDiv = row.querySelector('.editable-div');
              if (commentDiv) commentDiv.innerText = qData.comment;
            }
          }
        });
      }

      comps.forEach(c => updateCounters(c));
      if (!correction.nonNote && correction.note_finale !== "NN") calculateTotal();
      IS_SAVED = true;
    }

    function initSummary(activeComps, maxMap) {
      const tbody = document.getElementById('gradingBody');
      tbody.innerHTML = "";
      comps.forEach((c) => {
        const isVisible = activeComps.includes(c) || c === 'C6';
        const displayStyle = isVisible ? "" : "display:none;";
        const initialMax = maxMap[c] || 0;
        tbody.innerHTML += `<tr id="row_${c}" style="${displayStyle}">
          <td><span class="badge ${c.toLowerCase()}">${c}</span></td>
          <td>
            <input type="text" id="q_list_${c}" style="width:100%; border:none; text-align:center; font-size:0.85em; color:#666;" readonly>
            <div id="stats_${c}" class="stat-counters">ðŸ”´ 0 | ðŸŸ  0 | ðŸ”µ 0 | ðŸŸ¢ 0</div>
          </td>
          <td><input type="radio" name="r_${c}" value="NT" onclick="setGlobalLevel('${c}','NT')"></td>
          <td><input type="radio" name="r_${c}" value="I" onclick="setGlobalLevel('${c}','I')"></td>
          <td><input type="radio" name="r_${c}" value="A" onclick="setGlobalLevel('${c}','A')"></td>
          <td><input type="radio" name="r_${c}" value="M" onclick="setGlobalLevel('${c}','M')"></td>
          <td style="white-space:nowrap;">
            <input type="number" id="pts_${c}" class="score-input" step="0.25" placeholder="0" oninput="MANUAL_OVERRIDE['${c}']=true; this.style.color='#333'; this.title='Mode manuel'; calculateTotal(); markUnsaved();"> /
            <input type="number" id="max_${c}" class="max-input" step="0.5" value="${initialMax}" oninput="calculateTotal(); markUnsaved();">
          </td>
        </tr>`;
      });
      setTimeout(calculateTotal, 100);
    }

    function renderCorrection(blueprint, reponses) {
      const tbody = document.getElementById('correctionTable').querySelector('tbody');
      tbody.innerHTML = "";
      let maxMap = {}, qMap = {}, activeComps = [];

      const list = Array.isArray(blueprint?.questions) ? blueprint.questions : [];

      list.forEach((q, idx) => {
        const competence = (q && q.competence && /^C[1-6]$/.test(q.competence)) ? q.competence : "C6";
        const bareme = Number(q?.bareme) || 0;
        const label = q?.label || ("Q" + (idx + 1));
        const qid = q?.qid || `q_${idx}`;

        if(!activeComps.includes(competence)) activeComps.push(competence);
        maxMap[competence] = (maxMap[competence] || 0) + bareme;
        qMap[competence] = qMap[competence] || [];
        qMap[competence].push(label);

        const row = tbody.insertRow();
        row.dataset.comp = competence;
        row.dataset.level = "";
        row.dataset.qid = qid;
        row.dataset.bareme = bareme; // FIX #6 : stocker le barÃ¨me pour calcul semi-auto

        const repEleve = getReponseEleve(reponses, q);
        const attendu = formatExpected(q);
        const questionHtml = renderQuestionHTML(q, label, competence);

        row.innerHTML = `
          <td style="font-weight:bold">${escapeHTML(label)}</td>
          <td><span class="badge ${competence.toLowerCase()}">${competence}</span></td>
          <td>
            <div style="display:flex; gap:2px; justify-content:center;">
              <span class="level-btn nt" onclick="setNoteVisual(this, 'NT')">NT</span>
              <span class="level-btn i"  onclick="setNoteVisual(this, 'I')">I</span>
              <span class="level-btn a"  onclick="setNoteVisual(this, 'A')">A</span>
              <span class="level-btn m"  onclick="setNoteVisual(this, 'M')">M</span>
            </div>
          </td>
          <td class="qa-stack">
            ${questionHtml}
            <div class="qa-block qa-student">
              <div class="qa-title"><span class="pill e">RÃ©ponse Ã©lÃ¨ve</span></div>
              <div class="qa-content">${repEleve}</div>
            </div>
            <div class="qa-block qa-expected">
              <div class="qa-title"><span class="pill a">Attendu</span></div>
              <div class="qa-content">${attendu}</div>
            </div>
          </td>
          <td>
            <div class="editable-div" contenteditable="true" placeholder="ðŸ’¡ Commentaire..." oninput="markUnsaved()"></div>
          </td>
        `;
      });

      if(!maxMap['C6']) maxMap['C6'] = 2;
      initSummary(activeComps, maxMap);
      for(let c in qMap) {
        const el = document.getElementById(`q_list_${c}`);
        if(el) el.value = qMap[c].join(", ");
      }

      syncToggleButtons();
    }

    // FIX #6 : Ratios barÃ¨me semi-auto (modifiable par le prof)
    const LEVEL_RATIO = { M: 1.0, A: 0.66, I: 0.33, NT: 0 };
    // FIX #6 : Tracker les compÃ©tences en mode manuel (modifiÃ©es Ã  la main)
    const MANUAL_OVERRIDE = {};

    function setNoteVisual(btn, level) {
      const row = btn.closest('tr');
      Array.from(btn.parentNode.children).forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      row.dataset.level = level;
      updateCounters(row.dataset.comp);
      autoCalculatePoints(row.dataset.comp); // FIX #6 : recalcul semi-auto
      updateDominantLevel(row.dataset.comp); // FIX #7 : niveau dominant
      markUnsaved();
      openCommentBank(row.dataset.comp, level, row.querySelector('.editable-div'));
    }

    // FIX #6 : Calcul semi-auto des points par compÃ©tence
    function autoCalculatePoints(comp) {
      if (MANUAL_OVERRIDE[comp]) return; // Ne pas Ã©craser si le prof a modifiÃ© manuellement
      let totalPts = 0;
      document.querySelectorAll('#correctionTable tbody tr').forEach(r => {
        if (r.dataset.comp === comp && r.dataset.level) {
          const bareme = parseFloat(r.dataset.bareme) || 0;
          const ratio = LEVEL_RATIO[r.dataset.level] ?? 0;
          totalPts += bareme * ratio;
        }
      });
      const ptsEl = document.getElementById(`pts_${comp}`);
      if (ptsEl) {
        ptsEl.value = Math.round(totalPts * 4) / 4; // Arrondi au 0.25
        ptsEl.style.color = "#2e7bb6"; // Bleu = auto
        ptsEl.title = "CalculÃ© automatiquement (modifiable)";
      }
      calculateTotal();
    }

    // FIX #7 : Calcul et affichage du niveau dominant par compÃ©tence
    function updateDominantLevel(comp) {
      let counts = { NT: 0, I: 0, A: 0, M: 0 };
      let total = 0;
      document.querySelectorAll('#correctionTable tbody tr').forEach(r => {
        if (r.dataset.comp === comp && r.dataset.level) {
          counts[r.dataset.level]++;
          total++;
        }
      });
      if (total === 0) return;
      // Niveau dominant = celui qui apparaÃ®t le plus
      const dominant = Object.entries(counts).sort((a, b) => b[1] - a[1])[0][0];
      const levelColors = { M: '#5cb85c', A: '#f0c05a', I: '#d9534f', NT: '#7f8c8d' };
      const levelEmoji = { M: 'ðŸŸ¢', A: 'ðŸ”µ', I: 'ðŸŸ ', NT: 'ðŸ”´' };
      const display = document.getElementById(`dominant_${comp}`);
      if (display) {
        display.textContent = `${levelEmoji[dominant]} ${dominant}`;
        display.style.color = levelColors[dominant];
        display.style.fontWeight = 'bold';
      }
    }

    // FIX #7 : Les radios du rÃ©capitulatif mettent TOUTES les questions d'une compÃ©tence au mÃªme niveau
    function setGlobalLevel(comp, level) {
      document.querySelectorAll('#correctionTable tbody tr').forEach(r => {
        if (r.dataset.comp === comp) {
          r.dataset.level = level;
          const btns = r.querySelectorAll('.level-btn');
          btns.forEach(b => b.classList.remove('active'));
          const target = r.querySelector(`.level-btn.${level.toLowerCase()}`);
          if (target) target.classList.add('active');
        }
      });
      updateCounters(comp);
      autoCalculatePoints(comp);
      updateDominantLevel(comp);
      markUnsaved();
    }

    function updateCounters(comp) {
      let counts = { NT:0, I:0, A:0, M:0 };
      document.querySelectorAll('#correctionTable tbody tr').forEach(r => {
        if(r.dataset.comp === comp && r.dataset.level) counts[r.dataset.level]++;
      });
      const statBox = document.getElementById(`stats_${comp}`);
      if(statBox) statBox.innerHTML = `ðŸ”´ ${counts.NT} | ðŸŸ  ${counts.I} | ðŸ”µ ${counts.A} | ðŸŸ¢ ${counts.M}`;
      updateProgress(); // FIX #12
    }

    // FIX #12 : Mise Ã  jour de la barre de progression
    function updateProgress() {
      const rows = document.querySelectorAll('#correctionTable tbody tr');
      const total = rows.length;
      let noted = 0;
      rows.forEach(r => { if (r.dataset.level) noted++; });
      const pct = total > 0 ? Math.round((noted / total) * 100) : 0;
      const textEl = document.getElementById('progressText');
      const fillEl = document.getElementById('progressFill');
      const pctEl = document.getElementById('progressPct');
      if (textEl) textEl.textContent = `${noted} / ${total} questions notÃ©es`;
      if (fillEl) fillEl.style.width = pct + '%';
      if (pctEl) {
        pctEl.textContent = pct + '%';
        pctEl.style.color = pct === 100 ? '#16a34a' : pct > 50 ? '#2e7bb6' : '#d9534f';
      }
    }

    function calculateTotal() {
      let totalPts = 0;
      comps.forEach(c => {
        const row = document.getElementById(`row_${c}`);
        if(row && row.style.display !== 'none') {
          const v = document.getElementById(`pts_${c}`)?.value;
          totalPts += parseFloat(String(v ?? "0").replace(",", ".")) || 0;
        }
      });
      const elNote = document.getElementById('finalNote');
      elNote.innerText = totalPts.toFixed(1) + " / 20";
      elNote.style.color = totalPts < 10 ? "#d9534f" : "#16a34a";
    }

    // FIX #8 : Banque de commentaires dynamique
    // â€” Ajout de commentaires personnalisÃ©s
    // â€” Compteur de frÃ©quence d'utilisation (tri par usage)
    // â€” Persistance localStorage
    const COMMENT_STATS_KEY = "grille_comment_stats";
    const CUSTOM_COMMENTS_KEY = "grille_custom_comments";

    function loadCommentStats() {
      try { return JSON.parse(localStorage.getItem(COMMENT_STATS_KEY) || "{}"); } catch(e) { return {}; }
    }
    function saveCommentStats(stats) {
      try { localStorage.setItem(COMMENT_STATS_KEY, JSON.stringify(stats)); } catch(e) {}
    }
    function loadCustomComments() {
      try { return JSON.parse(localStorage.getItem(CUSTOM_COMMENTS_KEY) || "{}"); } catch(e) { return {}; }
    }
    function saveCustomComments(custom) {
      try { localStorage.setItem(CUSTOM_COMMENTS_KEY, JSON.stringify(custom)); } catch(e) {}
    }

    function incrementCommentUsage(comp, level, txt) {
      const stats = loadCommentStats();
      const key = `${comp}_${level}`;
      if (!stats[key]) stats[key] = {};
      stats[key][txt] = (stats[key][txt] || 0) + 1;
      saveCommentStats(stats);
    }

    function getCommentUsage(comp, level, txt) {
      const stats = loadCommentStats();
      const key = `${comp}_${level}`;
      return stats[key]?.[txt] || 0;
    }

    function openCommentBank(comp, level, target) {
      CURRENT_TARGET_DIV = target;
      const list = document.getElementById('modalList');
      list.innerHTML = "";
      document.getElementById('modalTitle').innerText = `Banque ${comp} (${level})`;

      // Collecter tous les commentaires (statiques + perso)
      const allPhrases = [];
      const compData = window.DATA_COMMENTAIRES_COMPETENCES?.[comp];
      if (compData) {
        for (const [catName, levelsObj] of Object.entries(compData)) {
          const phrases = levelsObj[level];
          if (phrases && phrases.length > 0) {
            phrases.forEach(txt => allPhrases.push({ txt, cat: catName, custom: false }));
          }
        }
      }

      // Commentaires personnalisÃ©s
      const custom = loadCustomComments();
      const customKey = `${comp}_${level}`;
      if (custom[customKey] && custom[customKey].length > 0) {
        custom[customKey].forEach(txt => allPhrases.push({ txt, cat: "âœï¸ Mes commentaires", custom: true }));
      }

      if (allPhrases.length === 0 && !compData) {
        list.innerHTML = "<div style='padding:20px; text-align:center;'>Pas de donnÃ©es.</div>";
      } else {
        // Trier par frÃ©quence d'utilisation (les plus utilisÃ©s en premier)
        allPhrases.sort((a, b) => {
          const freqA = getCommentUsage(comp, level, a.txt);
          const freqB = getCommentUsage(comp, level, b.txt);
          if (freqB !== freqA) return freqB - freqA;
          return 0; // Garder l'ordre d'origine si mÃªme frÃ©quence
        });

        // Grouper par catÃ©gorie
        const grouped = {};
        allPhrases.forEach(p => {
          if (!grouped[p.cat]) grouped[p.cat] = [];
          grouped[p.cat].push(p);
        });

        // Section "FrÃ©quents" si au moins un commentaire a Ã©tÃ© utilisÃ©
        const stats = loadCommentStats();
        const statsKey = `${comp}_${level}`;
        const frequents = allPhrases.filter(p => getCommentUsage(comp, level, p.txt) > 0)
          .sort((a, b) => getCommentUsage(comp, level, b.txt) - getCommentUsage(comp, level, a.txt))
          .slice(0, 5);

        if (frequents.length > 0) {
          const h = document.createElement("div");
          h.className = "bank-title";
          h.innerHTML = "â­ Les plus utilisÃ©s";
          list.appendChild(h);
          frequents.forEach(p => {
            const usage = getCommentUsage(comp, level, p.txt);
            list.appendChild(createCommentItem(p.txt, comp, level, usage));
          });
        }

        // Puis les catÃ©gories classiques
        for (const [catName, phrases] of Object.entries(grouped)) {
          const h = document.createElement("div");
          h.className = "bank-title";
          h.innerText = catName;
          list.appendChild(h);
          phrases.forEach(p => {
            const usage = getCommentUsage(comp, level, p.txt);
            const item = createCommentItem(p.txt, comp, level, usage);
            // Bouton supprimer pour les commentaires personnalisÃ©s
            if (p.custom) {
              const delBtn = document.createElement('span');
              delBtn.textContent = 'ðŸ—‘ï¸';
              delBtn.style.cssText = 'cursor:pointer; float:right; opacity:0.5; font-size:0.9em;';
              delBtn.title = 'Supprimer ce commentaire';
              delBtn.onclick = (e) => {
                e.stopPropagation();
                if (confirm("Supprimer ce commentaire personnalisÃ© ?")) {
                  const c = loadCustomComments();
                  c[customKey] = (c[customKey] || []).filter(t => t !== p.txt);
                  saveCustomComments(c);
                  openCommentBank(comp, level, target); // Recharger
                }
              };
              item.prepend(delBtn);
            }
            list.appendChild(item);
          });
        }
      }

      // Barre d'ajout personnalisÃ© en bas
      const addBar = document.createElement('div');
      addBar.style.cssText = 'padding:10px 15px; border-top:2px solid #e2e8f0; display:flex; gap:8px; align-items:center; background:#f8fafc;';
      addBar.innerHTML = `
        <input type="text" id="customCommentInput" placeholder="âœï¸ Ajouter un commentaire personnalisÃ©..." 
          style="flex:1; padding:6px 10px; border:1px solid #cbd5e1; border-radius:6px; font-size:0.9em;">
        <button onclick="addCustomComment('${comp}','${level}')" 
          style="padding:6px 14px; background:#2e7bb6; color:white; border:none; border-radius:6px; cursor:pointer; font-weight:bold; font-size:0.9em;">+ Ajouter</button>
      `;
      list.appendChild(addBar);

      // Permettre l'ajout avec EntrÃ©e
      setTimeout(() => {
        const input = document.getElementById('customCommentInput');
        if (input) {
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); addCustomComment(comp, level); }
          });
        }
      }, 100);

      document.getElementById('commentModal').style.display = "flex";
    }

    function createCommentItem(txt, comp, level, usage) {
      const d = document.createElement('div');
      d.className = "comment-item";
      d.style.display = 'flex';
      d.style.justifyContent = 'space-between';
      d.style.alignItems = 'center';
      const textSpan = document.createElement('span');
      textSpan.textContent = txt;
      textSpan.style.flex = '1';
      d.appendChild(textSpan);
      if (usage > 0) {
        const badge = document.createElement('span');
        badge.textContent = `Ã—${usage}`;
        badge.style.cssText = 'font-size:0.7em; background:#e2e8f0; color:#64748b; padding:1px 6px; border-radius:10px; margin-left:8px; white-space:nowrap;';
        d.appendChild(badge);
      }
      d.onclick = () => {
        const prev = CURRENT_TARGET_DIV.innerText.trim();
        CURRENT_TARGET_DIV.innerText = prev ? (prev + " " + txt) : txt;
        incrementCommentUsage(comp, level, txt);
        closeModal();
        markUnsaved();
      };
      return d;
    }

    window.addCustomComment = function(comp, level) {
      const input = document.getElementById('customCommentInput');
      if (!input) return;
      const txt = input.value.trim();
      if (!txt) { input.focus(); return; }
      const custom = loadCustomComments();
      const key = `${comp}_${level}`;
      if (!custom[key]) custom[key] = [];
      if (custom[key].includes(txt)) { alert("Ce commentaire existe dÃ©jÃ ."); return; }
      custom[key].push(txt);
      saveCustomComments(custom);
      // InsÃ©rer directement le commentaire
      const prev = CURRENT_TARGET_DIV.innerText.trim();
      CURRENT_TARGET_DIV.innerText = prev ? (prev + " " + txt) : txt;
      incrementCommentUsage(comp, level, txt);
      closeModal();
      markUnsaved();
    }

    function openAppreciationBank() {
      CURRENT_TARGET_DIV = document.getElementById('appreciationArea');
      const list = document.getElementById('modalList');
      list.innerHTML = "";
      document.getElementById('modalTitle').innerText = "ApprÃ©ciations";

      const apprData = window.DATA_APPRECIATION || {};
      for (const [catName, data] of Object.entries(apprData)) {
        const h = document.createElement("div");
        h.className = "bank-title";
        h.innerText = catName;
        list.appendChild(h);

        if(Array.isArray(data)) {
          data.forEach(txt => {
            const d = document.createElement('div');
            d.className = "comment-item";
            d.innerText = txt;
            d.onclick = () => { insertText(txt, true); };
            list.appendChild(d);
          });
        } else if (typeof data === 'object') {
          for (const [comp, phrases] of Object.entries(data)) {
            phrases.forEach(txt => {
              const d = document.createElement('div');
              d.className = "comment-item";
              d.innerHTML = `<strong>(${escapeHTML(comp)})</strong> ${escapeHTML(txt)}`;
              d.onclick = () => { insertText(`(${comp}) ${txt}`, true); };
              list.appendChild(d);
            });
          }
        }
      }
      document.getElementById('commentModal').style.display = "flex";
    }

    function insertText(text, newLine) {
      if(CURRENT_TARGET_DIV) {
        const sep = (CURRENT_TARGET_DIV.value.length > 0 && newLine) ? "\n" : " ";
        CURRENT_TARGET_DIV.value += sep + text;
        autoResize(CURRENT_TARGET_DIV);
      }
      closeModal();
      markUnsaved();
    }

    function closeModal() { document.getElementById('commentModal').style.display = "none"; }

    function sortTable(n) {
      const table = document.getElementById("correctionTable");
      const tbody = table.querySelector('tbody'); // FIX #17 : cibler tbody, pas table
      let rows = Array.from(tbody.rows);
      rows.sort((a, b) => {
        let t1 = a.cells[n].innerText.toLowerCase();
        let t2 = b.cells[n].innerText.toLowerCase();
        if(n===0) return (parseFloat(t1) || 0) - (parseFloat(t2) || 0);
        return t1.localeCompare(t2);
      });
      rows.forEach(r => tbody.appendChild(r)); // FIX #17 : append dans tbody
    }

    function resetNewStudent() {
      if (!IS_SAVED && !confirm("âš ï¸ Modifications non enregistrÃ©es !\n\nQuitter quand mÃªme ?")) return;
      // FIX #4 : Fallback robuste si window.close() Ã©choue (onglet ouvert manuellement)
      try { window.close(); } catch(e) { /* ignorÃ© */ }
      // Si la fenÃªtre est toujours ouverte aprÃ¨s 200ms, proposer une alternative
      setTimeout(() => {
        if (!window.closed) {
          if (window.opener) {
            window.opener.focus();
          } else if (document.referrer) {
            window.location.href = document.referrer;
          } else {
            // RÃ©initialiser la page pour une nouvelle copie
            document.getElementById('docTitle').innerText = "âš ï¸ Aucune copie";
            document.getElementById('statusText').innerHTML = "ðŸ”„ Retournez au Cockpit pour sÃ©lectionner une autre copie.";
            document.getElementById('statusBanner').className = 'status-banner auth-required';
            alert("Retournez au Cockpit pour ouvrir une autre copie.");
          }
        }
      }, 200);
    }

    async function init() {
      console.log("ðŸš€ Grille V18 - DÃ©marrage (audit complet â€” 21 fixes)...");
      loadPreferences();
      initSummary([], {});
      updateStatusBanner();

      const rawData = localStorage.getItem("cockpit_transfert");
      if (!rawData) {
        document.getElementById('docTitle').innerText = "âš ï¸ Aucune copie";
        document.getElementById('statusText').innerHTML = "âŒ Utilisez le bouton Grille depuis le Cockpit";
        return;
      }
      // FIX #2 : NE PAS supprimer tout de suite â€” on attend que le chargement rÃ©ussisse

      try {
        const copyFromStorage = JSON.parse(rawData);
        CURRENT_DOC_ID = copyFromStorage.id;
        CURRENT_ELEVE_CODE = copyFromStorage.eleveCode || copyFromStorage.userCode || null;

        if (!CURRENT_ELEVE_CODE && copyFromStorage.path) {
          const parts = copyFromStorage.path.split('/');
          if (parts[0] === 'resultats') CURRENT_ELEVE_CODE = parts[1];
        }

        let docSnap = null;
        if (CURRENT_ELEVE_CODE && copyFromStorage.path) {
          docSnap = await getDoc(doc(db, copyFromStorage.path));
        }
        if (!docSnap || !docSnap.exists()) {
          docSnap = await getDoc(doc(db, "devoirs_rendus", CURRENT_DOC_ID));
          if (docSnap.exists()) {
            const data = docSnap.data();
            CURRENT_ELEVE_CODE = CURRENT_ELEVE_CODE || data.eleve?.userCode || data.userCode || data.eleveCode;
          }
        }
        if (!docSnap || !docSnap.exists()) throw new Error("Document non trouvÃ©");

        CURRENT_COPY = docSnap.data();
        CURRENT_COPY.id = CURRENT_DOC_ID;
        // FIX #2 : Supprimer localStorage seulement APRÃˆS chargement rÃ©ussi
        localStorage.removeItem("cockpit_transfert");
        if (!CURRENT_ELEVE_CODE) CURRENT_ELEVE_CODE = CURRENT_COPY.eleve?.userCode || CURRENT_COPY.userCode || "UNKNOWN";

        // Annuaire local : resolution nom/prenom depuis le code
        if (typeof AnnuaireLocal !== 'undefined' && AnnuaireLocal.isLoaded()) {
          const nomComplet = AnnuaireLocal.getNom(CURRENT_ELEVE_CODE);
          if (nomComplet) {
            const parts = nomComplet.split(' ');
            document.getElementById('inputPrenom').value = parts[0] || "";
            document.getElementById('inputNom').value = parts.slice(1).join(' ') || CURRENT_ELEVE_CODE;
          } else {
            document.getElementById('inputNom').value = CURRENT_ELEVE_CODE || "";
            document.getElementById('inputPrenom').value = "";
          }
        } else {
          document.getElementById('inputNom').value = CURRENT_ELEVE_CODE || "";
          document.getElementById('inputPrenom').value = "";
        }
        document.getElementById('inputClasse').value = CURRENT_COPY.eleve?.classe || CURRENT_COPY.classe || "";
        document.getElementById('inputDate').value = new Date().toISOString().split('T')[0];

        const devoirId = String(CURRENT_COPY.devoirId || "").trim().replace(/[^a-zA-Z0-9_-]/g, "");
        if (!devoirId) throw new Error("devoirId invalide");

        const resp = await fetch(`${devoirId}_blueprint.json?ts=${Date.now()}`, { cache: "no-store" });
        if (!resp.ok) throw new Error("Blueprint non trouvÃ©: " + devoirId);

        CURRENT_BLUEPRINT = await resp.json();
        document.getElementById('docTitle').innerText = "Correction : " + (CURRENT_BLUEPRINT.titre || devoirId);

        const questions = extractQuestionsFromBlueprint(CURRENT_BLUEPRINT);
        renderCorrection({ questions }, CURRENT_COPY.reponses || {});

        if (CURRENT_ELEVE_CODE !== "UNKNOWN") {
          try {
            const evalSnap = await getDoc(doc(db, "resultats", CURRENT_ELEVE_CODE, "evaluations", devoirId + "_eval"));
            if (evalSnap.exists()) {
              CURRENT_EVALUATION = evalSnap.data();
              loadExistingCorrection(CURRENT_EVALUATION);
              IS_SAVED = true;
            } else if (CURRENT_COPY.correction) {
              CURRENT_EVALUATION = CURRENT_COPY.correction;
              loadExistingCorrection(CURRENT_COPY.correction);
              IS_SAVED = true;
            }
          } catch(e) {
            // FIX #3 : Signaler l'erreur au lieu de l'avaler silencieusement
            console.warn("âš ï¸ Impossible de charger une correction existante:", e.message);
            IS_SAVED = false;
            const banner = document.getElementById('statusText');
            if (banner) banner.innerHTML = "âš ï¸ Correction existante non chargÃ©e (vÃ©rifiez votre connexion)";
            document.getElementById('statusBanner').className = 'status-banner not-saved';
          }
        }

        updateStatusBanner();
        console.log("âœ… Grille V18 prÃªte !");
      } catch (e) {
        document.getElementById('statusText').innerHTML = "âŒ " + e.message;
        document.getElementById('statusBanner').classList.add('not-saved');
        console.error("âŒ", e);
        handleFirebaseError(e, "chargement copie"); // FIX #20
      }
    }

    // FIX #13 : Raccourcis clavier â€” cliquer sur une ligne puis 1=NT, 2=I, 3=A, 4=M
    let FOCUSED_ROW = null;
    document.addEventListener('click', (e) => {
      const row = e.target.closest('#correctionTable tbody tr');
      if (row) {
        if (FOCUSED_ROW) FOCUSED_ROW.style.outline = '';
        FOCUSED_ROW = row;
        row.style.outline = '2px solid #2e7bb6';
        row.style.outlineOffset = '-2px';
      }
    });
    document.addEventListener('keydown', (e) => {
      // Ne pas intercepter si on est dans un champ de saisie
      if (e.target.matches('input, textarea, [contenteditable="true"]')) return;
      if (!FOCUSED_ROW) return;
      const keyMap = { '1': 'NT', '2': 'I', '3': 'A', '4': 'M', 'Numpad1': 'NT', 'Numpad2': 'I', 'Numpad3': 'A', 'Numpad4': 'M' };
      const level = keyMap[e.key] || keyMap[e.code];
      if (level) {
        e.preventDefault();
        const btn = FOCUSED_ROW.querySelector(`.level-btn.${level.toLowerCase()}`);
        if (btn) btn.click();
        // Passer Ã  la question suivante
        const next = FOCUSED_ROW.nextElementSibling;
        if (next && next.matches('tr')) {
          FOCUSED_ROW.style.outline = '';
          FOCUSED_ROW = next;
          next.style.outline = '2px solid #2e7bb6';
          next.style.outlineOffset = '-2px';
          next.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
      // Tab = passer Ã  la question suivante sans noter
      if (e.key === 'Tab' && !e.shiftKey) {
        e.preventDefault();
        const next = FOCUSED_ROW.nextElementSibling;
        if (next && next.matches('tr')) {
          FOCUSED_ROW.style.outline = '';
          FOCUSED_ROW = next;
          next.style.outline = '2px solid #2e7bb6';
          next.style.outlineOffset = '-2px';
          next.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    });

    // FIX #14 : Sauvegarde auto du brouillon quand l'onglet perd le focus (mobile + desktop)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden' && !IS_SAVED && currentUser && CURRENT_ELEVE_CODE && CURRENT_ELEVE_CODE !== 'UNKNOWN') {
        // Sauvegarde silencieuse en brouillon
        try {
          const brouillon = collecterDonneesCorrection();
          brouillon.statut = "brouillon_auto";
          brouillon.note_finale = parseFloat((document.getElementById('finalNote').textContent || "0").replace(",", ".")) || 0;
          brouillon.publie = false;
          const brouillonDocId = brouillon.devoirId + "_brouillon";
          setDoc(doc(db, "resultats", CURRENT_ELEVE_CODE, "brouillons", brouillonDocId), brouillon)
            .then(() => console.log("ðŸ’¾ Brouillon auto sauvegardÃ© (visibilitychange)"))
            .catch(err => console.warn("âš ï¸ Brouillon auto Ã©chouÃ©:", err.message));
        } catch(e) { console.warn("âš ï¸ Brouillon auto Ã©chouÃ©:", e.message); }
      }
    });

    window.addEventListener('beforeunload', (e) => { if (!IS_SAVED) { e.preventDefault(); e.returnValue = ''; } });
    // Annuaire local : bouton UI
    if (typeof AnnuaireLocal !== 'undefined') {
      const ac = document.getElementById('annuaireContainer');
      if (ac) AnnuaireLocal.renderButton(ac);
      document.addEventListener('annuaire-updated', function() {
        if (typeof CURRENT_ELEVE_CODE !== 'undefined' && CURRENT_ELEVE_CODE && AnnuaireLocal.isLoaded()) {
          const nc = AnnuaireLocal.getNom(CURRENT_ELEVE_CODE);
          if (nc) {
            const p = nc.split(' ');
            document.getElementById('inputPrenom').value = p[0] || "";
            document.getElementById('inputNom').value = p.slice(1).join(' ') || CURRENT_ELEVE_CODE;
          }
        }
      });
    }

    init();
  </script>
</body>
</html>
